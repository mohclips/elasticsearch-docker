# vim: set syntax=Logstash noai:ts=2:sw=2:et

filter {

    #
    # queries.log
    #
    if [log][file][path] =~ /\/var\/log\/named\/queries.log/ {

      dissect {
        id => "bind_dissect"
        mapping => { 
          #10-Sep-2020 20:22:14.747 queries: info: client @0x7fb23c7f80a0 172.30.5.194#42042 (a.root-servers.net): query: a.root-servers.net IN A + (172.30.5.253)
          #"message" => "%{logdate} queries: info: client @%{?hex} %{client.ip}#%{client.port} (%{?bind.query1}): query: %{dns.question.name} %{dns.question.class} %{dns.question.type} %{dns.header_flags} (%{server.ip})" 
          "message" => "%{logdate} queries: info: client @%{?hex} %{[client][ip]}#%{[client][port]} (%{?bind.query1}): query: %{[dns][question][name]} %{[dns][question][class]} %{[dns][question][type]} %{[dns][header_flags]} (%{[server][ip]})" 
          }
        add_tag => [ "dns_query" ]
      }

    #
    # rpz log
    #
    } else if [log][file][path] =~ /\/var\/log\/named\/rpz.log/ {
    
      dissect {
        id => "rpz_dissect"
        mapping => { 
          #             10-Sep-2020 20:51:36.667 rpz: info: client @0x7fb23cad43c0 172.30.5.102#58610 (web.facebook.com): rpz QNAME NXDOMAIN rewrite web.facebook.com via web.facebook.com.facebook.local
          "message" => "%{logdate} rpz: info: client @%{?hex} %{[client][ip]}#%{[client][port]} (%{?bind.query1}): rpz QNAME NXDOMAIN rewrite %{[dns][question][name]} via %{?redirect}" 
          }
        add_tag => [ "dns_rpz" ]
      }
    #
    # dnscap log
    #
    } else if [log][file][path] =~ /\/var\/log\/named\/dnscap.log/ {

      mutate {
        add_tag => [ "dns_cap" ]
      }
    
      if [message] =~ " tp=A " and [message] =~ " rc=OK " {
        dissect {
          id => "dnscap_dissect_A"
          mapping => { 
            #            2020 12/10 23:05:55 src=172.30.5.253 spt=53 dst=172.30.5.194 dpt=59831 proto=UDP mid=44959 op=0 fl=|QR|RD|RA| rc=OK cl=IN tp=A name=a.root-servers.net ans=198.41.0.4
            "message" => "%{y} %{md} %{t} src=%{?dnsip} spt=%{?spt} dst=%{[client][ip]} dpt=%{[client][port]} proto=%{protocol} mid=%{[event][id]} op=%{op} fl=%{[dns][header_flags]} rc=%{rc} cl=%{[dns][question][class]} tp=%{[dns][question][type]} name=%{[dns][question][name]} ans=%{ans}" 
            }
        }

        # flag is RPZ response or not - our RPZ returns localhost IP if in RPZ zone
        if [ans] == "127.0.0.1" {
          mutate {
            add_tag => [ "dnscap_rpz" ]
          }
        } else {
          mutate {
            add_tag => [ "dnscap_good" ]
          }
        }

      }
      # now bad A record eg. SERVFAIL
      else if [message] =~ " tp=A " and [message] !~ " rc=OK " {
        dissect {
          id => "dnscap_dissect_Abad"
          mapping => { 
            #            2020 12/10 23:05:55 src=172.30.5.253 spt=53 dst=172.30.5.194 dpt=59831 proto=UDP mid=44959 op=0 fl=|QR|RD|RA| rc=OK cl=IN tp=A name=a.root-servers.net ans=198.41.0.4
            "message" => "%{y} %{md} %{t} src=%{?dnsip} spt=%{?spt} dst=%{[client][ip]} dpt=%{[client][port]} proto=%{protocol} mid=%{[event][id]} op=%{op} fl=%{[dns][header_flags]} rc=%{rc} cl=%{[dns][question][class]} tp=%{[dns][question][type]} name=%{[dns][question][name]}" 
            }
        }
      }
      else if [message] =~ " tp=PTR " {
        dissect {
          id => "dnscap_dissect_PTR"
          mapping => { 
            #             2020 12/10 23:47:18 src=172.30.5.253 spt=53 dst=172.30.5.67 dpt=43137 proto=UDP mid=3971 op=0 fl=|QR|AA|RD|RA| rc=OK cl=IN tp=PTR name=175.5.30.172.in-addr.arpa
            "message" => "%{y} %{md} %{t} src=%{?dnsip} spt=%{?spt} dst=%{[client][ip]} dpt=%{[client][port]} proto=%{protocol} mid=%{[event][id]} op=%{op} fl=%{[dns][header_flags]} rc=%{rc} cl=%{[dns][question][class]} tp=%{[dns][question][type]} name=%{[dns][question][name]}" 
            }
        }
      }
      else if [message] =~ " tp=AAAA " {
        dissect {
          id => "dnscap_dissect_AAAA"
          mapping => { 
            
            "message" => "%{y} %{md} %{t} src=%{?dnsip} spt=%{?spt} dst=%{[client][ip]} dpt=%{[client][port]} proto=%{protocol} mid=%{[event][id]} op=%{op} fl=%{[dns][header_flags]} rc=%{rc} cl=%{[dns][question][class]} tp=%{[dns][question][type]} name=%{[dns][question][name]}" 
            }
        }
      }

      date {
        id => "cap_date"
        match => [ "%{y} %{md} %{t}", "YYYY MM/DD HH:mm:ss" ]
        # it's already Zulu
        #timezone => "Etc/UTC"
      }

      mutate {
        # house keeping for dnscap
        remove_field => [ "y", "md", "t", "protocol", "op" ]
      }


    } else {

      mutate {
        add_tag => [ "dns_broken" ]
      }
    }

    date {
      #14-Jul-2020 20:25:01.365
      id => "bind_date"
      match => [ "logdate", "dd-MMM-YYYY HH:mm:ss.SSS" ]
      # it's already Zulu
      timezone => "Etc/UTC"
    }

    mutate {
      id => "bind_cfg"
      copy => { "[agent][name]" => "[server][name]" }

      # copy client ip here, so we can resolve it and replace it with the DNS filter
      copy => { "[client][ip]" => "[client][address]" }
    }

    # do a look up of the local ip
    dns {
      reverse => [ "[client][address]" ]

      nameserver => {
          address => ["172.30.5.253"]
      }

      action => "replace"
      hit_cache_size => 8000 
      hit_cache_ttl => 300 
      failed_cache_size => 1000 
      failed_cache_ttl => 300

      #hostsfile => [ "/usr/share/logstash/config/hostsfile" ]
    }

    # tidy
    if "_dissectfailure" not in [tags] {
      mutate {
        id => "bind_tidy"
        remove_field => [ "agent", "event", "logdate", "message", "log.offset" ]
        #add_tag => [ "idm_dns" ]
        remove_tag => [ "beats_input_codec_plain_applied" ]
      }
    }
} # filter
